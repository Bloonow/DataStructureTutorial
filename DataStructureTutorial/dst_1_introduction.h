// Author：Akame Qixisi / Excel Bloonow
// 作者： 巫见 / 血梦墨雪

#ifndef DST_1_INTRODUCTION_H
#define DST_1_INTRODUCTION_H

// 第一章：绪论

// 数据结构教程（第5版） 清华大学出版社
// Data Structure Tutorial
namespace dst {
	// 1 绪论
	// 最后修改：2019-12-16
	namespace _1 {
		// 1.1 什么是数据结构

		// 1.1.1 数据结构的定义
		// 通常以数据元素作为数据结构的基本单位
		// 数据项（data item）是具有独立含义的数据的最小单位，也称字段或域
		// 数据对象（data object）是指性质相同的数据元素的集合，它是数据的一个子集
		// 数据结构（data structure）是指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合
		// 数据结构通常包括以下几个方面：
		//	(1)、数据的逻辑结构（logical structure）：由数据元素之间的逻辑关系构成
		//	(2)、数据的存储结构（storage structure）：数据元素及其关系在计算机存储器中的存储表示，也称数据的物理结构（physical structure）
		//	(3)、数据的运算（operation）：施加在该数据上的操作

		// 1.1.2 逻辑结构
		// 1.1.2.1 逻辑结构的表示
		//	(1)、图表表示
		//	(2)、二元组表示
		//		 B = ( D, R )，其中 B 是一种数据逻辑结构，它由数据元素的集合 D 以及D上的二元关系的集合 R 所组成
		//		 D = { di | 1 <= i <= n, n >= 0 }，R = { ri | 1 <= j <= m, m >= 0 }
		//		 R 中的一个关系 r 是序偶的集合，对于 r 中的任一序偶 <x,y>（x,y ∈ D），表示元素 x 和元素 y 之间是相邻的，即 x 在 y 之前，x 是该序偶的第一元素，y 是第二元素
		//		 而且 x 为 y 的直接前驱元素（predecessor），y 为 x 的直接后继元素（successor），简称前驱元素和后继元素
		//		 若某个元素没有前驱元素，则该元素为开始元素（first element）；若某个元素没有后继元素，则该元素为终端元素（terminal element）
		// 1.1.2.2 逻辑结构的类型
		//	(1)、集合（set）
		//	(2)、线性结构（linear structure），数据元素之间为一对一的关系
		//	(3)、树形结构，数据元素之间为一对多的关系
		//  (4)、图形结构，数据元素之间为多对多的关系

		// 1.1.3 存储结构
		// 数据逻辑结构在计算机存储器中的存储表示称为数据的存储结构（也称为映像），也就是逻辑结构在计算机中的存储实现
		// 1.1.3.1 顺序存储结构（sequential storage structure）
		// 1.1.3.2 链式存储结构（linked storage structure）
		// 1.1.3.3 索引存储结构（indexed storage structure）
		// 1.1.3.4 哈希（或散列）存储结构（hashed storage structure）

		// 1.1.4 数据运算
		// 数据运算是指对数据实施的操作，最常用的有检索、插入、删除、更新和排序等

		// 1.1.5 数据类型和抽象数据类型
		// 1.1.5.1 数据类型（data type）是一组性质相同的值的集合和定义在此集合上的一组操作的总称，是某种程序设计语言中已实现的数据结构
		// 1.1.5.2 抽象数据类型（Abstract Data Type，ADT）
		// 指的是用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑结构和逻辑结构上的运算，而不考虑计算机的具体存储结构和运算的具体实现算法
		// 一个抽象数据类型可用 (D, S, P) 三元组表示，其中D是数据对象，S是D上的关系，P是D中数据的基本运算集，抽象数据类型的基本描述格式如下：
		// ADT 抽象数据类型名 {
		//		数据对象：数据对象的声明
		//		数据关系：数据关系的声明
		//		基本运算：基本运算的声明
		// }
		// 其中，基本运算的声明格式为，基本运算名(参数表)：运算功能描述

		// 1.2 算法及其描述

		// 1.2.1 什么是算法
		// 算法（algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列
		//	1、有穷性，2、确定性，3、可行性，4、有输入，5、有输出

		// 1.2.2 算法的设计目标
		//	1、正确性，2、可使用性，3、可读性，4、健壮性，5、高效率与低存储量需求

		// 1.2.3 算法描述
		// 1.2.3.1 算法描述的一般格式和设计步骤
		// 1.2.3.2 输出型参数的设计

		// 1.3 算法分析

		// 1.3.1 算法分析概述
		// 算法分析就是分析算法占用计算机资源的多少

		// 1.3.2 算法时间性能分析
		// 1.3.2.1 两种算法时间性能分析方法
		//	1、事后统计法，2、事前估计法
		// 1.3.2.2 算法时间复杂度分析
		//	1、计算算法的频度 T(n)
		// 一个算法是由控制结构（顺序、分支和循环三种）和原操作（值固有数据类型的操作）构成的
		// 算法时间分析即求出算法所有原操作的执行次数（也称频度），它是问题规模 n 的函数，用 T(n) 表示
		//	2、T(n) 用 "O" 表示
		//	   算法的时间复杂度（time complexity）就是用 T(n) 的数量级来表示，记作 T(n) = O(f(n))
		//	   在上述表达式中的O是Order的简写，意指数量级，其含义是为 T(n) 找到一个上界 f(n)，其严格的数学定义是 T(n) 的数量级表示为 O(f(n))，是指
		//	   存在着正常量 c 和 n0（为一个足够大的正整数），使得 Lim(n-->n0){ |T(n)| / |f(n)| } = c != 0 成立
		//	   所以算法的时间复杂度也称为渐进时间复杂度，它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同
		//	   因此算法时间复杂度分析实际上是一种时间增长趋势分析
		//	   根据其趋势不同，分为多项式时间复杂度（polynomial time complexity）和指数时间复杂度（exponential time complexity）等
		//	   O(1) < O(log2(n)) < O(n) < O(n*log2(n)) < O(n^2) < O(n^3) < O(2^n) < O(n!)
		//	3、简化的时间复杂度分析
		//	   即仅仅考虑算法中的基本操作（指算法中最深层循环内的原操作）的执行次数
		//	4、时间复杂度的求和、求积定理
		//	   假设 T1(n) 和 T2(n) 分别是程序段 P1、P2 的执行时间，并且 T1(n) = O(f(n))，T2(n) = O(g(n))
		//	   求和定理：先执行 P1，再执行 P2，总执行时间是：T1(n) + T2(n) = O(MAX{ f(n), g(n) })
		//	   求积定理：程序嵌套执行，总执行时间是： T1(n) * T2(n) = O ( f(n) * g(n) )
		// 1.3.2.3 算法的最好、最坏和平均时间复杂度
		// 设一个算法的输入规模为 n，Dn 是所有输入（实例）的集合，任意输入 I ∈ Dn，P(I) 是 I 出现的频率，有 ∑(I∈Dn){ P(I) } = 1
		// T(I) 是算法再输入 I 下所执行的基本操作的次数，则算法的平均时间复杂度定义为：E(n) = ∑(I∈Dn){ P(I) * T(I) }
		// 算法的最好时间复杂度是指在最好情况下的时间复杂度，即 B(n) = MIN(I∈Dn){ T(n) }
		// 算法的最坏时间复杂度是指在最坏情况下的时间复杂度，即 W(n) = MAX(I∈Dn){ T(n) }
		// 1.3.2.4 递归算法时间复杂度分析
		// 在递归算法中首先写出对应的递推式，然后求解递推式得出算法的执行时间或空间

		// 1.3.3 算法空间性能分析
		// 1.3.3.1 算法空间复杂度分析
		// 对算法进行存储空间分析时只考察临时变量所占的空间，不计形参占用的空间
		// 算法空间复杂度（space complexity）是对一个算法在运行过程中临时占用的存储空间大小的度量，一般也作为问题规模 n 的函数，以数量级的形式给出，记作
		// S(n) = O(g(n))
		// 若所需临时空间相对于问题规模来说是常数，则称此算法为原地工作算法或就地工作算法
		// 1.3.3.2 递归算法空间复杂度分析
		// 对于递归算法，为了实现递归过程用到一个递归栈，所以需要根据递归深度得到算法的空间复杂度

		// 1.4 数据结构 + 算法 = 程序

        // 1.4.1 程序和数据结构
		
		// 1.4.2 算法和程序
		
		// 1.4.3 算法和数据结构
		// 1.4.3.1 存储结构的存储能力
		// 1.4.4.2 存储结构应于所选择的算法相适应

		// 1.4.4 数据结构的发展

	} // END namespace _1 绪论

} // END namespace dst

#endif // !DST_1_INTRODUCTION_H