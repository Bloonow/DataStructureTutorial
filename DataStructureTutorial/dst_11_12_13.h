// Author：Akame Qixisi / Excel Bloonow
// 作者： 巫见 / 血梦墨雪

#ifndef DST_11_12_13
#define DST_11_12_13

// 第十一章：外排序
// 第十二章：文件
// 第十三章：采用面向对象的方法描述算法
// 由于教材中以上三章内容无实现代码，只是论述思想，故将这三章归于此头文件

// 数据结构教程（第5版） 清华大学出版社
// Data Structure Tutorial
namespace dst {
	// 11 外排序（external sort）
	// 最后修改：2020-01-06
	namespace _11 {
		// 11.1 外排序概述
		// 文件存储在外存上，因此外排序方法与各种外存设备的特征有关，外存设备大体上可分为两类
		// 一类是顺序存取设备，例如磁带（tape）；另一类是直接存取设备，例如磁盘（disk）
		// 对于磁盘来说，一般有读写头、主轴、盘面、柱面、磁带等物理和逻辑结构组成
		// 一般情况下，把一次向磁盘写入或读出的数据称为一个物理块，一个物理块通常由若干记录组成
		// 外排序的基本方法是归并排序法，它分为以下两个步骤
		// (1)、生成若干初始归并段（顺串，runs）：将一个文件（含待排序数据）中的数据分段读入内存，在内存中对其进行内排序，并将经过排序的数据段（有序段）写到多个外存文件上
		// (2)、多路归并：对这些初始归并段进行多遍归并，使得有序的归并段逐渐扩大，最后在外存上形成整个文件的单一归并段，也就完成了这个文件的外排序
		// 从中可以看出，外排序的时间主要花费在内、外存数据的交换（对应存取时间）和内排序上


		// 11.2 磁盘排序（disk sort）

		// 11.2.1 磁盘排序概述
		// 由于是直接存取设备，读写一个数据块的时间与当前读写头所处的位置关系不大，所以可以通过读写数据块的次数来衡量存取时间
		// 对磁盘中的文件 Fin 进行排序，通过算法将 Fin 文件中的记录一部分一部分地调入内存处理，产生若干个文件 F1，...，Fn，它们都是有序的，称为顺串（runs）
		// 然后再次将 F1，...，Fn 文件中的记录调入内存，通过相关的归并算法（几路归并则同时从几个文件的开头处理）产生一个有序文件 Fout，从而达到数据排序的目的
		// 不同于内排序，磁盘排序中元素移动的次数相对于记录读写次数和关键字比较次数可以忽略，所以一般不考虑元素移动的时间开销
		// 因此可以大致认为，磁盘排序时间 = 读写记录次数 + 关键字比较次数

		// 12.2.2 生成初始归并段
		// 一般情况下，初始归并段的个数越多，多路归并的性能越差，这里介绍一种 置换-选择排序（replacement selection sorting）算法，从而减少初始归并段的个数，如下：
		// (1)、从待排序文件中 Fin 中按内存工作区 WA 的容量（设为 w）读入 w 个记录，设归并段编号 i = 1
		// (2)、从 WA 中选出关键字最小的记录 Rmin
		// (3)、将 Rmin 记录输出到文件 Fi 中，作为当前归并段的一个记录
		// (4)、若 Fin 不为空，则从 Fin 中读入下一个记录到 WA 中替代刚输出的记录
		// (5)、在 WA 工作区中所有大于等于 Rmin 的记录中选择最小的记录作为新的 Rmin，转(3)，直到选不出这样的 Rmin
		// (6)、置 i = i + 1，开始一个新的归并段
		// (7)、若 WA 工作区不为空，转(2)，否则 WA 工作区为空，初始归并段已全部产生，算法结束
		// 显然，置换-选择排序算法生成的初始归并段的长度既与内存工作区WA的大小有关，也与输入文件中记录的排序次序有关
		// 可以证明，如果输入文件中的记录按关键字随机排列，所得到的初始归并段的平均长度为内存工作区大小的两倍
		// 在置换-选择排序算法中，内存工作区WA内频繁的操作是，从w个记录中选择一个关键字最小的记录，如果采用基于简单选择的排序方法，每次操作需要w-1次比较
		// 若输入文件有n个记录，则算法的时间复杂度为O(nw)，实际上这种频繁的操作可以采用败者树来实现，从w个记录中选择一个关键字最小的记录的时间为O(log2w)
		// 从而使置换-选择排序算法的时间复杂度降低为 O(n*log2w)

		// 12.2.3 多路平衡归并
		
		// 1、k 路平衡归并的效率分析
		// 所谓二路平衡归并（2-way balanced merge）就是每一趟从 m 个归并段得到 ⌈m/2⌉ 个归并段
		// 这样归并树就有 ⌈log2m⌉ + 1 层（根上归并完的那个结点单独占一层），需要对初始数据进行 ⌈log2m⌉ 遍扫描
		// 做类似的推广，当采用 k 路平衡归并时，相应的归并树有 ⌈logk(m)⌉ + 1 层，要对数据进行 s = ⌈logk(m)⌉ 遍扫描，显然 k 越大，磁盘的读写次数越少
		// 在进行 k 路归并时，在 k 个记录中选择最小者，如果采用基于简单比较的的排序方法，需要进行 k-1 次比较，每趟归并 u 个记录需要做 (u-1)*(k-1) 次关键字比较
		// 则 s 趟归并总共需要的关键字比较次数为 s*(u-1)*(k-1) = ⌈logk(m)⌉*(u-1)*(k-1) = ⌈log2m⌉*(u-1)*(k-1)/⌈log2k⌉
		// 从中可以看出，在初始归并段个数 m 与记录个数 u 确定时，其中的前两项是常量，而 (k-1)/⌈log2k⌉ 随着 k 的增大而增大
		// 因此，若 m 与 u 确定，在选择几路归并方案时，尽管增大归并路数 k 会减少磁盘读写次数，但 k 增大会增加关键字比较次数
		// 当 k 增大到一定程度，就会抵消由于减少磁盘读写次数所赢得的时间
		// 也就是说，在 k 路平衡归并中，如果采用基于简单选择排序方法，其效率并非 k 越大，归并的效率就越好
		
		// 2、利用败者树的 k 路平衡归并
		// 利用败者树实现 k 路平衡归并的过程是先建立败者树，然后对 k 个输入有序段进行 k 路平衡归并。
		// 败者树（tree of loser）是一棵有 k 个叶子结点的完全二叉树（可将大根堆看成胜者树），其中叶子结点存储参与归并的记录，分支结点存放关键字对应的段号
		// 所谓败者是两个记录比较时关键字较大者，胜者是两个记录比较时关键字较小者
		// 建立败者树是采用类似于堆调整的方法实现的，初始时令所有的分支结点指向一个含最小关键字（MINKEY）的叶子结点，然后从各叶子结点出发调整分支结点为新的败者即可
		// 对 k 个有序段进行 k 路平衡归并的方法如下：
		// (1)、取每个输入有序段的第一个记录作为败者树的叶子结点，建立初始败者树：
		//		两两叶子结点进行比较，在双亲结点中存放比较的败者（关键字较大者），而让胜者去参加更高一层的比赛，如此在根结点之上胜出的“冠军”是关键字最小者
		// (2)、将胜出的记录写至输出归并段，在对应的叶子结点处补充其输入有序段的下一个记录，若该有序段变空，则补充一个大关键字（比所有记录关键字都大，设为k(max)）的虚记录
		// (3)、调整败者树，选择新的关键字最小的记录：
		//		从补充的记录的叶子结点向上和双亲结点的关键字比较，败者留在该双亲结点，胜者继续向上，直到树的根结点，最后将胜者放在根结点的双亲结点中
		// (4)、若胜出的记录关键字等于 k(max)，则归并结束；否则转 (2) 继续
		// 说明：在上一小节的置换-选择排序的算法中第(2)步从WA中选出关键字最小的记录时也可以使用败者树方法以提高算法效率
		// 显然，k 路平衡归并的高度为 ⌈log2k⌉ + 1，在每次调整找下一个具有最小关键字的记录时仅需要做 ⌈log2k⌉ 次关键字比较
		// 因此，若初始归并段为 m 个，利用败者树在 k 个记录中选择最小者只需要进行 ⌈log2k⌉ 次关键字比较，则 s = ⌈logk(m)⌉ 趟归并总共需要关键字比较次数为：
		// s * (u-1) * ⌈log2k⌉ = ⌈logk(m)⌉ * (u-1) * ⌈log2k⌉ = ⌈log2m⌉ * (u-1)
		// 关键字比较次数与 k 无关，总的内部归并时间并不会随 k 的增大而增大；且 k 越大，归并树的高度越小，读写磁盘的次数也较少
		// 因此，当采用败者树实现多路平衡归并时，只要内存空间允许，增大归并路数 k 会有效地减少归并树的高度，从而减少读写磁盘次数，提高外排序的速度
		
		// 11.2.4 最佳归并树
		// 由于采用置换-选择排序算法生成的初始归并段长度不等，在进行逐趟 k 路归并时对归并段的组合不同，会导致归并过程中读写记录的次数不同
		// 按照最佳归并树的设计可以使归并过程中对外存的读写次数最少
		// 归并树是描述归并过程的 k 次树，因为每一次做 k 路归并对需要有 k 个归并段参加，因此归并树是只包含度为 0 和度为 k 的结点的标准 k 次树
		// 各叶子结点代表参加归并的各初始段，叶子结点上的权值为该初始段中的记录个数，根结点代表最终生成的归并段
		// 叶子结点到根结点的路径长度表示在归并过程中的读记录次数，各非叶子结点代表归并出来的新归并段
		// 则归并树的带权路径长度 WPL 即为归并过程中的总读记录数，因此在归并过程中的读写记录次数为 2 * WPL
		// 为了使总的读写次数达到最少，需要改变归并方案，重新组织归并树，使其路径长度 WPL 尽可能小，所有归并树中最小带权路径长度WPL的归并树成为最佳归并树（optimal merge tree）
		// 为此，可将哈夫曼树的思想扩充到 k 次树的情形：在归并树中，让记录个少的初始段先归并，记录个数多的初始段最晚归并
		// 为了使归并树成为一棵标准 k 次树，可能需要补入虚段（dummy run，记录个数为 0 的归并段）
		// 设参加归并的初始段有 m 个，做 k 路平衡归并
		// 因为归并树是只有度为 0 和度为 k 的结点的正则 k 次树，显然度为 0 的结点有 m 个（因为初始归并段有 m 个，对应归并树的度为零的叶子结点就有 m 个）
		// 度为 k 的结点有 mk 个，则有 m = mk * k + 1 - mk = (k-1) * mk + 1（叶子结点数 = 所有结点 - 非叶子结点数）
		// 因此，可以得出 mk = (m-1) / (k-1)，设 u = (m-1) % (k-1)
		// 若 u == 0，则说明这 m 个叶子结点正好可以构造 k 次归并树，不需要加虚段，此时分支结点有 mk 个
		// 若 u != 0，则需要补入 t 个虚段，使得剩下的 u 个初始归并段加上 t 个虚段能正好被 (k-1) 除尽，此时分支结点有 mk + 1 个
		// 综上所述，分支结点个数 mk = ⌈(m-1) / (k-1)⌉
		// 因此，最佳归并树是带权路径长度最短的 k 次（阶）哈夫曼树，其构造步骤如下：
		// (1)、若 (m-1) % (k-1) != 0，则需要附加 (k-1) - ((m-1) % (k-1)) 个长度为 0 的虚段，以使每次归并都可以对应 k 个段
		// (2)、按照哈夫曼树的构造原则（权值越小的结点离根结点越远）构造最佳归并树


		// 11.3 磁带排序（tape sort）

		// 11.3.1 多路平衡归并排序
		// 磁带的多路平衡归并排序过程与磁盘的多路平衡归并排序过程基本上相同
		// 磁带排序（tape sort）和磁盘排序的主要区别在于磁带排序需要充分考虑归并段的分布状况，因为磁带是顺序存取的，所以各归并段在不同磁带和同一磁带的不同位置对排序效率影响极大
		// 对磁带排序来说，多路归并需要多台磁带，为了避免过多的磁带寻找时间，要归并的归并段需要放在不同的磁带上
		// 因此，k 路归并至少需要 k+1 台磁带，其中 k 台作为输入带，另一台为归并后输出之用
		// 但是这样需要对输出带再做一遍扫描，把输出带上的各归并段重新分配到 k 台磁带上，以便作为下一级归并使用
		// 若使用 2k 台磁带，则可避免这种再分配扫描，把 k 台作为输入带，其余 k 台作为输出带，在下一级归并时输入带与输出带的作用互相对换
		
		// 11.3.2 多阶段归并排序
		// 所谓的多阶段归并排序实际上是多路非平衡排序，即各条带上的归并段不再保持平衡分布
		// 它在 k 路归并中仅使用 k+1 条磁带就可以避免在多路平衡归并排序算法中遇到的重新分布有序段的问题
		// 开始时，初始归并段不平衡地分配在前 k 条磁带上，第 k+1 条磁带作为输出带，初始为空
		// 第一步归并只是部分记录参加，归并段最少的带在本步归并完成后便成为空带，作为下一次归并的输出带
		// 这样，k+1 条磁带将轮流成为输出带，直到整个文件为一个排序文件为止
		// 为了使归并的趟数达到最小，必须合理地分配各磁带上初始归并段的段数，通过分析可得出以下结论：归并段的总数以及在各带上分布情况与 k 阶 Fibonacci（斐波那契）序列有关
		// 设 Fk(i) 为 k 阶 Fibonacci 序列中的第 i 项，利用 k+1 台磁带机做 k 路多阶段归并时，若初始段归并的总数为：
		// T = k * Fk(i) + (k-1) * Fk(i-1) + ... + 2 * Fk(i-(k-2)) + Fk(i-(k-1)) = ∑(j=0->k-1){ (k-j) * Fk(i-j) }
		// 则需要进行 i-k+2 个归并段的归并，初始归并段在各带上分布的段数应为：Tt = ∑(j=0->k-t){ Fk(i-j) }
		// 其中，Tt 表示第 t 条磁带上的归并段的段数，其中（1<= t <= k）
		// 其中，k 阶Fibonacci 数列可用下面的递推公式导出（第 i 项，从 0 开始）：
		// Fk(i) = 0，i <= k-2，前 k-1 项
		// Fk(i) = 1，i == k-1，第 k 项
		// Fk(i) = Fk(i-1) + Fk(i-2) + ... + Fk(i-k)，i >= k，从第 k+1 项及之后
		// 综上所述，k 阶 Fibonacci 序列为：前 k-1 项为 0，第 k 项为 1，从第 k+1 项开始每项等于前 k 项之和
		// 当 k 取 2 时，其退化为普通的斐波那契数列

	} // END namespace _11 外排序

	// 12 文件（file）
	// 最后修改：2020-01-06
	namespace _12 {
		// 12.1 文件的基本概念
		// 12.1.1 什么是文件
		// 文件（file）是性质相同的记录的集合，文件的数据量通常很大，它被放置在外存上，数据结构中所讨论的文件主要是数据库意义上的文件，而不是操作系统意义上的文件
		// 操作系统中研究的文件是一维的无结构连续字符的序列；数据库中所研究的文件是带有结构的记录集合，每个记录可由若干数据项构成
		// 记录是文件中存取的基本单位，数据项是文件可使用的最小单位，数据项有时也称为字段
		// 其值能唯一标识一个记录的数据项或数据项的组合称为主关键字（primary key），其他不能唯一标识一个记录的数据则称为次关键字（secondary key）
		// 文件可以按照记录中关键字的多少分成单关键字文件和多关键字文件
		// 文件又可以分为定长文件和不定长文件，若文件中记录含有的信息长度相同，则称这类记录为定长记录，由定长记录组成的文件成为定长文件；若记录含有的信息长度不同，称为不定长文件
		// 和其他数据结构一样，文件结构也包括逻辑结构、存储结构以及在文件上的各种操作（运算）这三个方面，文件的操作是定义在逻辑结构上的，但操作的具体实现要在存储结构上进行
		
		// 12.1.2 文件的逻辑结构及操作
		// 文件中各记录之间存在着逻辑关系，当一个文件的各个记录按照某种次序排列起来时（可以根据关键字大小，也可以根据各个记录存入该文件的时间先后等）
		// 各记录之间就自然的形成了一种线性关系，在这种次序下，每个记录最多只有一个前驱和一个后继（开始记录和终止记录分别没有前驱和后继），因此文件可看成是一种线性结构
		// 文件上的操作主要有两类：检索和维护
		// 文件检索就是在文件中查找满足给定条件的记录，它既可以按记录的逻辑号（即记录保存入文件时的顺序编号），也可以按关键字查找
		// 文件维护主要是指对文件进行记录的插入、删除及修改等更新操作，此外为了提高文件的效率，还要进行再组织操作、文件被破坏后的恢复操作，以及文件中数据的安全保护等

		// 12.1.3 文件的存储结构
		// 文件的存储结构是指文件在外存上的组织方式，采用不同的组织方式就得到了不同的存储结构，基本的组织方式有四种：顺序组织、索引组织、哈希组织和链式组织
		// 文件组织的方式往往是这四种基本方式的结合，选择哪一种文件组织方式取决于对文件中记录的使用方式和频繁程度、存取要求、外存的性质和容量等


		// 12.2 顺序文件（sequential file）
		// 顺序文件是指按记录进入文件的先后顺序在放、其逻辑顺序跟物理顺序一致的文件
		// 若顺序文件中的记录按其主关键字有序，则称此顺序文件为顺序有序文件，否则称为顺序无序文件，为了提高检索效率，经常将顺序文件组织成有序文件
		// 1、一切存储在顺序存取存储器（如磁带）上的文件都只能是顺序文件
		// 顺序文件只能按顺序查找法存取，即顺序扫描文件，按记录的主关键字逐个查找，如果要检索第 i 个记录，必须检索前 i-1个记录
		// 这种查找法对于少量的检索是不经济的，但适合于批量检索，即把用户的检索要求先进行积累，一旦待查记录聚集到一定数量之后
		// 便把这批记录按主关键字排序，然后通过一次顺序扫描文件来完成这一批检索要求
		// 2、存储在直接存取存储器（如磁盘）上的顺序文件可以用顺序查找法存取，也可以用分块查找法或二分查找法进行存取
		// 分块查找法在查找时不必扫描整个文件中的记录，先通过关键字找到相应的块，再扫描这个块即可
		// 二分查找法只能对较小的文件或一个文件的索引进行查找，当文件很大，在磁盘上占有多个柱面时，二分查找将引起磁头来回移动，增加寻查时间
		// 3、顺序文件不能按顺序表那样的方法进行插入、删除和修改（若修改主关键字，则相当于先做删除后做插入）
		// 因为文件中的记录不能像向量空间的数据那样“移动”，而只能通过复制整个文件的方法实现上述更新操作，这就是为什么数据库系统总会产生很多临时文件的原因
		// 4、顺序文件的主要优点是连续存取的速度较快，即若文件中第 i 个记录刚被存取过，而下一个要存取的是第 i+1 个记录，则这种存取将会很快完成
		// 当顺序文件存放在单一存储设备（如磁带）上时，这个优点总是可以保持的
		// 而当它是存放在多路存储设备（如磁盘）上时，在多道程序的情况下，由于其他用户可能驱使磁头移向其他柱面，就会降低这一优点
		// 因此，顺序文件多用于磁带


		// 12.3 索引文件（indexed file）
		// 在用索引的方法组织文件时通常是在文件本身（称为主文件）之外另外建立一张表，它指明逻辑记录和物理记录之间的一一对应关系
		// 这张表就称为索引表（index table），它和主文件一起构成的文件称为索引文件（indexed file）
		// 1、索引表中的每一项称为索引项（index item），一般索引项都是由主关键字和该关键字所在记录的物理地址组成的
		// 显然，索引表必须按主关键字有序，而主文件本身则可以按主关键字有序或无序
		// 如果主文件有序称为索引顺序文件（indexed sequential file），如果主文件无序称为索引非顺序文件（indexed non-sequential file)
		// 2、对于索引非顺序文件，由于主文件中的记录是无序的，则必须为每个记录建立一个索引项，这样建立的索引表称为稠密索引
		// 对于索引顺序文件，由于主文件中的记录按关键字有序，则可对一组记录建立一个索引项，例如让文件中的每个物理块对应一个索引项，这种索引表称为稀疏索引
		// 通常将索引非顺序文件简称为索引文件，本节只讨论这种文件
		// 3、索引文件在存储器上分为两个区，即索引区和数据区，前者存放索引表，后者存放主文件
		// 在建立文件的过程中按输入记录的先后次序建立数据区和索引表，这样的索引表其关键字是无序的
		// 待全部记录输入完毕后再对索引表进行排序，排序后的索引表和主文件一起就形成了索引文件
		// 4、检索分两步进行，首先将外存上含有索引区的物理块送入内存，查找所需记录的物理地址，然后再将含有该记录的物理块送人内存
		// 若索引表不大，则可将索引表一次读入内存，因此在索引文件中进行检索只需两次访问外存，即一次读索引、一次读记录
		// 由于索引表是有序的，所以对索引表的查找可用顺序查找或二分查找等方法
		// 5、索引文件的更新操作也很简单，在插入时将插入记录置于数据区的末尾，并在索引表中插入索引项；在删除时删去相应的索引项；若要修改键字，则必须同时修改索引表
		// 6、当记录数目很大时，索引表也很大，以至于一个物理块容纳不下，在这种情况下查阅索引仍要多次访问外存，为此可以对索引表建立一个索引，称为查找表
		// 上节介绍的索引非顺序文件适合于随机存取，这是由于主文件是无序的，顺序存取将会频繁地引起磁头移动，因此索引非顺序文件不适合于顺序存取
		// 而索引顺序文件的主文件也是有序的，所以它既适合于随机存取，也适合于顺序存取
		// 另外，索引顺序文件由于主文件是按主关键字有序的，因此索引表采取稀疏索引，占用的空间较少
		// 它是常用的一种文件组织结构，此处将介绍两种最常用的索引顺序文件，即 ISAM 文件和 VSAM 文件

		// 12.3.1 ISAM 文件（索引顺序存取方法，indexed sequential access method）
		// ISAM文件是一种采用静态索引结构的磁盘存取文件，由于磁盘是盘组、柱面和磁道的三级地址存储设备，因此对磁盘上的数据文件建立盘组、柱面和磁道多级索引
		// ISAM文件由以下3个部分组成：
		//		1. 基本数据区
		//		由一个或多个柱面组成，文件的记录按关键字有序存放于柱面的每个磁道上
		//		2. 溢出区
		//		每个柱面都开一个溢出区，为插入记录而设，当一个磁道存满记录以后，如果要在该磁道插入记录，就将该磁道的最后一个记录移至溢出区
		//		再将新记录插在此磁道的适当位置，每个磁道的溢出数据在溢出区中组成链表
		//		3. 多级素引
		//		多级索引都采用稀疏索引，各级索引的结构如下：
		//			1) 磁道索引
		//			其包括基本索引项和溢出索引项，基本索引项含本磁道的最大关键字及起始地址；溢出索引项含本磁道溢出记录的最大关键字及本磁道溢出区首地址
		//			2) 柱面索引
		//			索引项包含柱面中的最大关键字和该柱面磁道索引的起始地址
		//			3) 主索引
		//			主索引是柱面索引的索引，每个索引项包含柱面索引中一组记录的最大关键字及该面索引组的起始地址
		//			检索时由高级索引到低级索引逐级查找，找到待查记录所在的磁道后再到此磁道中查找待查记录
		// 1、因柱面基本区中的主文件按关键字有序，因此可对每个磁道上的记录建立一个磁道索引项，一个柱面上的所有磁道索引项形成一个磁道索引
		// 然后对每个磁道索引块（即同属一个柱面的磁道索引块）建立一个柱面索引项，盘组上对应主文件的所有柱面索引项形成柱面索引
		// 若柱面索引较大，再建立称为主索引的柱面索引的索引；若文件的柱面索引很大，使得一级主引也很大时，主索引可建立多级；当然，若柱面索引较小，也可不建主索引，以减小索引高度
		// 2、每个柱面分为磁道索引区、基本区和溢出区三个部分
		// 磁道索引区用来存放该柱面的磁道索引，通常规定该柱面最前面的磁道 T0 为磁道索引区，由 T1 开始的若干个磁道用来存放主文件的记录，称为基本区
		// 每个柱面最后若干个磁道称为溢出区，每个柱面的溢出区由该柱面基本区中的各个磁道共享，溢出区为有序链表结构，简称溢出链表
		// 3、每个磁道索引项有4项，即基本索引项关键字、基本索引项指针、溢出索引项关键字和溢出索引项指针
		// 其中基本索引项关键字为对应磁道在基本区中最末一个记录的关键字（即该磁道的最大关键字），基本索引项指针指示该磁道中第一个记录在基本区中的位置
		// 溢出索引项关键字为对应溢出链表的最大关键字，溢出索引项指针为对应溢出链表的头指针
		// 4、每个柱面索引项有两项，即关键字和指针，关键字为对应柱面（即对应磁道索引块）中最后一个记录的关键字（即该柱面的最大关键字），指针指示对应柱面上的磁道索引首地址
		// 如前所述，磁道索引放在对应柱面的第一个磁道，即指针指示对应柱面第一个磁道中磁道索引的起始地址
		// 5、在数据文件初始建立时，磁道索引的溢出索引项均为空，各个柱面溢出区也均为空
		// 当有新的记录插入时需要重组某个磁道的记录，并将该磁道最后一个记录移入该柱面的溢出链表中，同时修改对应磁道索引的基本索引项和溢出索引项内容
		// 6、在ISAM文件中删除记录的操作比较简单，只要找到待删除的记录，在其存储位置上加一个删除标志即可，而不需要移动记录和修改索引
		// 记录检索有成功和失败两种情况，在ISAM文件中记录检索成功时的检索路径有下面两种：
		//	(1)、若被检索记录在某柱面的基本区中，则检索路径为：主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面基本区中某磁道有序表的顺序扫描
		//	(2)、若被检索记录在某柱面的溢出区中，则检索路径为：主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面有序溢出链表的顺序扫描
		// 7、在ISAM文件中记录检索失败时的检索路径也有两种：
		//	(1)、主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面基本区中某磁道有序表的顺序扫描 -> 检	索失败
		//	(2)、主索引 -> 柱面索引 -> 某磁道索引 -> 某柱面有序溢出链表的顺序扫描 -> 检索失败
		// 8、在ISAM文件中经过多次记录增别后文件的结构可能变得很不合理，此时大量的记录进入溢出区，而基本区中又浪费了很多的空间
		// 因此通常需要周期性地整理ISAM文件，把记录读入内存重新排列，复制成一个新的ISAM文件，填满基本区而空出溢出区

		// 12.3.2 VSAM 文件（虚拟存储存取方法，virtual storage access method）
		// VSAM文件是一种采用虚拟存储存取方法的文件，VSAM文件的存储单位是控制区间和控制区域，这是一些逻辑存储单位，与柱面、磁道等实际存储单位并没有必然的联系
		// 用户在存取VSAM文件的记录时不需要考虑该记录的当前位置是在内存还是在外存，也不需要考虑何时执行对外存进行读写的命令，可见，这种文件较ISAM文件更方便用户使用
		// 就文件的组织方式来说，VSAM文件和ISAM文件的相同点是都是索引顺序文件组织方式，其不同点是ISAM文件采用静态索引结构，而VSAM采用 B+树 的动态索引结构
		// 一个VSAM文件的例子，它由数据集、顺序集和索引集3个部分组成
		// (1)、数据集：一个结点称为一个控制区间，它是 I/O 操作的一个基本单位，文件的记录存放于数据集中
		// 一个控制区间除存放一个或多个记录以外，还包含有记录的控制信息和区间的控制信息，且每个控制区间留有空间，为插入记录时备用
		// (2)、顺序集：存放每个控制区间的索引项，一个索引项包含该控制区间的最大关键字和指向区间的指针
		// 若干个控制区间的索引项组成顺序集中的一个结点，结点之间用指针链接，使整个顺序集形成一个链表，顺序集中一个结点和与之对应的控制区间组成一个控制区域
		// (3)、索引集：每个顺序集的结点又在其上一层的结点中建立索引，且逐层向上建立索引，每个索引项都是由下层若干个结点的最大关键字和指向这些结点的指针组成
		// 这些层的索引组成了索引集，它们是 B+ 树的非终端结点，与顺序集共同构成一棵 B+ 树，作为文件的索引部分
		// 1、VSAM文件的记录均存放在数据集中（其中的一个结点就是一个控制区间）, 每个控制区间存放有若干个按关键字有序排列的记录
		// 控制区间的大小可随文件的不同而不同，但同一文件中控制区间的大小相同
		// 顺序集和索引集一起构成一棵 B+ 树，为有序记录的索引，顺序集和索引集中的所有索引项都由关键字和指针两部分组成
		// 每个控制区间在顺序集中都有一个索引项，其关键字为控制区间中记录的最大关键字，其指针为该控制区间的首地址，顺序集中的一个结点和对应的若干个控制区间组成的部分称为控制区域
		// 每个控制区间可看作一个逻辑磁道，每个控制区域可看作一个逻辑柱面，而控制区间相当于一个磁道
		// 2、与ISAM文件不同的是，VSAM文件不设溢出区，解决记录插入的方法是在文件初始建立时留下一定的空间
		// 预留空间使用两种方法，一种方法是每个控制区间初建时不填满记录；另一种方法是在每个控制区域中留有一些全空的控制区间
		// 3、在VSAM文件中记录插入有4种情况：
		//	(1)、新记录能直接插入到相应的控制区间中，但需要修改顺序集中的索引项
		//	(2)、新记录插入的控制区间未满，但需把其中关键字大于插入记录关键字的记录后移
		//	(3)、新记录要插入的控制区间中记录已满，此时要进行控制区间的分裂，即将近一半记录移到同一控制区域中全空的控制区间中，并修改顺序集中相应的索引
		//	(4)、新记录要插入的控制区域中已没有全空的控制区间，要进行控制区域的分裂，此时顺序集中的结点也要分裂
		// 4、记录的删除过程与插入过程相反，当要删除记录时先查找到该记录，然后将该记录右面的记录顺次左移以使空闲空间连续，同时删除相应的控制信息
		// 若删除后该控制区间不再含有记录，则回收做空闲空间使用，同时删除顺序集中相应的索引项
		// 5、与ISAM文件相比，VSAM文件具有以下优点：1.动态地分配和释放存储空间；2.不需要对文件进行重组；3.插入新记录后对新记录的查找时间和对原有记录的查找时间相同
		// 基于 B+ 树的VSAM文件通常作为大型索引顺序文件的标准组织方式


		// 12.4 哈希文件（hashed file）
		// 哈希文件也称为散列文件，是利用哈希存储方式组织的文件，也称为直接存取文件
		// 它类似于哈希表，即根据文件中关键字的特点设计一个哈希函数和处理冲突的方法，将记录哈希到存储设备上
		// 1、与哈希表不同的是，对于文件来说，磁盘上的文件记录通常是成组存放的，若干个记录组成一个存储单位，在哈希文件中这个存储单位叫桶（bucket)
		// 假如一个桶能存放 m 个记录，则当桶中已有 m 个同义词的记录时存放第 m+1 个同义词会发生“溢出”
		// 处理溢出虽然可采用哈希表中处理冲突的各种方法，但对哈希文件而言主要采用链地址法
		// 2、当发生“溢出”时，需要将第 m+1 个同义词存放到另一个桶中，通常称此桶为“溢出桶”，相应的，称前m个同义词存放的桶为“基桶”
		// 溢出桶和基桶大小相同，相互之间用指针链接
		// 当在基桶中没有找到待查记录时就沿着指针到所指溢出桶中进行查找，因此希望同一哈希地址的溢出桶和基桶在磁盘上的物理位置不要相距太远，最好在同一柱面上
		// 3、在哈希文件中进行查找时首先根据给定值求出哈希桶的地址，将基桶的记录读入内存，进行顺序查找，若找到关键字等于给定值的记录，则检索成功
		// 否则，读入溢出桶的记录继续进行查找
		// 4、在哈希文件中删去一个记录仅需对被删记录做删除标记即可
		// 5、哈希文件的优点是文件随机存放，记录不需进行排序；插入、删除方便；存取速度快；不需要索引区，节省存储空间
		// 其缺点是不能进行顺序存取，只能按关键字随机存取，且询问方式限于简单询问，并且在经过多次插入、删除后也可能造成文件结构不合理，需要重新组织文件


		// 12.5 多关键字文件（multiple key file）
		// 以上各节介绍的都是只含一个主关键字的文件，为了提高查找效率，还需要对被查询的次关键字建立相应的索引，这种包含有多个次关键字索引的文件称为多关键字文件
		// 次关键字索引本身可以是顺序表，也可以是树表，下面讨论两种多关键字文件的组织方法

		// 12.5.1 多重表文件（multilist file）
		// 多重表文件是将索引方法和链接方法相结合的一种组织方式，它对每个需要查询的次关键字建立一个索引
		// 同时将具有相同次关键字的记录链接成一个链表，并将此链表的头指针、链表长度及次关键字作为索引表的一个索引项
		// 通常，多重表文件的主文件是一个顺序文件
		// 多重表文件在检索时同样先查询索引表，然后在主文件中读出待查记录信息；
		// 插入时如果不要求保持链表的某种次序，则可将新记录插在链表的头指针之后；
		// 删除记录时比较烦琐，需要在每个次关键字的链表中删去该记录

		// 12.5.2 倒排文件（inverted file）
		// 倒排文件和多重表文件的区别在于具有相同次关键字的记录不进行接，而是在相应的次关键字索引表的该索引项中直接列出这些记录的物理地址或记录号
		// 这样的索引表称为倒排表，由主文件和倒排表共同组成倒排文件
		// 倒排文件的主要优点是检索记录较快，在处理复杂的多关键字查询时可在倒排表中确定记录是哪个或哪些，继而直接读取之
		// 倒排文件的缺点是维护困难，在同一个倒排表中不同关键字的记录数不同，各倒排表的长度也不等

	} // END namespace _12 文件

	// 13 采用面向对象的方法描述算法
	// 最后修改：2020-01-06
	namespace _13 {
		// 13.1 面向对象的概念
		// 1. 对象
		// 2. 类
		// 3. 继承
		// 4. 消息
		// 1. 与人类习惯的思维方式一致
		// 2. 可重用性好
		// 3. 可维修性好

		// 13.2 用 C++ 描述面向对象的程序
		// 13.2.1 类
		//	1. 类的定义
		//	2. 类的成员函数
		//	3. 访问权限
		// 13.2.2 类对象
		//	1. 对象的定义格式
		//	2. 对象成员的表示方法
		// 12.2.3 构造函数和析构函数
		//	1. 构造函数
		//	2. 重载构造函数
		//	3. 析构函数
		// 12.2.4 模板类

		// 13.3 用 C++ 描述数据结构算法
		// 13.3.1 顺序表模板
		// 13.3.2 链栈类模板

		// 13.4 使用 STL 设计数据结构算法
		// 1. vector（向量容器）
		// 2. deque（双端队列容器）
		// 3. list（链表容器）
		// 4. stack（栈容器）
		// 5. queue（队列容器）

	} // END namespace _13 采用面向对象的方法描述算法

} // END namespace dst

#endif // !DST_11_12_13